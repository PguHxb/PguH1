递归与迭代都是基于控制结构：迭代用重复结构，而递归使用的则是选择结构。
递归与迭代都涉及重复，迭代显示使用重复结构而递归通过重复函数调用来实现现重复。
递归与迭代都涉及终止测试：迭代在循环条件失败是终止，递归在遇到基本的情况下终止。
使用计数器控制重复的迭代器和递归都逐渐到达终止点：迭代是一直修改计数器，直到计数器是循环条件失败，递归不断产生最初的问题来初始化副本，直达到达基本情况，
迭代和递归都可以无限制的进行：如果循环条件测试永远不变成false，则迭代发生无限循环，如果递归永远无法回推到基本情况，则发生无穷的递归。
递归函数是调用函数本身来完成任务的，而且在每次调用自身是减少任务量。
而迭代是循环的一种形式，这种循环不是由用户量输入而控制的，每次迭代步骤搜必须将剩下的任务减少，也就是说，循环的每一步都必须将执行一个有限的过程，并留下较少的过程。
递归是自顶向下逐步拓展需求的，最后在自下向顶运算。即由f(n)拓展到f(1),再由f(1)逐步算回f(n)，迭代就是直接自下向顶的运算，有f(1)算到f(n);





递归调用时非常浪费资源的，如果调用过多则会导致堆栈的溢出。 
例如：求一个n的累加：

function getsum(n){
	if(n === 1){
	return 1;
}
	return n + getsum(n-1);
}
console.log(getsum(100));
  
  结果就是5050

那么我们来分析一些递归调用的过程。

 首先我们解析，当解析到getsun函数时，即进入函数中，
 然后n大于1，所以会执行后一步的流程，当得到 n 时，又因为调用了getsum方法，所以就必须在执行这个函数，然后将值存储起来，等到下一步的运行结果再来计算。
 但最终执行到n ===1 时， 那么就是说该结束递归调用了，然后他就会将原先存储起来的数值进行累加，因为原先判断了当等于1的时候就该跳出这个循环。所以他会将累加的值返回出去。


接下来我在次使用一个例子来说明递归调用。
求数字的每项之和的相加  如123 每项之和的相加为6
那我们如何求每项的数呢。
第一项： 123%10=3   123/10=12.3  求余
第二项为  12%10=2   12/10 = 1.2
第三项    1.2%10=1   1.2/10=0.1
function getSum(n){
	if(n<10){//这里的判断是当n为10以下，即返回，结束递归
	return n;
}
	return n%10 + getSum(parserInt(n%10));//

}
console.log(getSum(123));

第一步：将123传入函数里面，判断是否小于10，因为不小于，所以就执行下面的语句。
第二步：getSum(123)
3+getSum(12)//这里的3将会给上面的函数存储起来；接下来就该执行getSum(12)了
2+getSum(1)//执行1的时候进行判断，因为1《10，所以就导致了判断该return n 了；
接下就是一步一步往上传回数据，将数据的总和相加起来。



