闭包，指的是有权访问另一个函数作用域中的函数变量的函数。就是读取其他函数内部变量的函数。
	又因为在JavaScript中，只有函数内部的子函数才可以读取局部变量，因此，也可以将闭包理解为定义在一个函数内部的函数，所以本质来说，闭包就是连接函数内部和函数外部的桥梁。



	闭包，在自己的理解中就是，访问另一个函数作用域中变量。但是函数却有作用域，那么外部函数是调用不到另一个函数的变量的，那么，我们就可以使用作用域链这一理念，在要访问的函数之内定义另一个函数，定义的函数是可以访问的到要访问的函数。因为可以访问是作用域链，内函数是可以访问外函数的。那么函数也是一个对象，也可以作为参数返回，所以，我们可以把我们定义的函数作为参数值返回，这样，外部就可以访问的到要访问的函数变量了。




	创建一个闭包函数的常见方式就是在一个函数内部创建另一个函数，
	function person(prototypename){
		return function(object1,oobject2){

			var value1 = object1[portotypename];
			var value2 = object2[prototypename];

			if(value1 < value2){
				return -1
		}else if(value1 > value2){
				return 1 ;
		}else{
			returnn 0;
		}
		}
	}

	上述的代码中，var value1 = object1[portotypename];
					var value2 = object2[prototypename];是内部函数(匿名函数)中的代码，这两行代码访问了外部函数中的变量prototypename，即使函数被调用，而且是在其他的地方被调用，但他仍然可以访问变量prototypename，之所以可以访问这个变量是因为内部函数作用域




	闭包的用途：
		1.可以读取函数内部的变量
		2.让这些变量的值始终保存在内存中：(为什么说将变量的值始终保存在内存中呢，那是因为当闭包函数访问他的父级函数的时候，其实，父级函数的变量是闭包中的，所以，闭包保留了一份对父级函数变量的引用，所以呢，如果闭包函数没有停止调用，那么，变量是一直会在内存中的。只有当闭包函数关闭的时候，JavaScript的回收机制才会来回收这些占用的内存。)

		对变量始终保存在内存中的再解释：
			一般函数访问一个变量的时候，会从作用域链中搜索具有相应名字的变量，一般来讲，函数执行完毕后，局部对象是会被销毁的，内存中仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况有所不同：
				因为闭包是在函数内部定义的的函数，，所以在一个函数内部定义的函数是会将包含的函数(父级函数)的活动对象添加到自己的作用域链中，所以当闭包返回之后，他的作用域链会被初始化为包含着父级函数的活动对象和全局变量对象，这样，闭包函数就可以访问父级函数定义的所有变量，更为重要的是，父级函数子啊执行完之后，其活动对象是不会被销毁的，因为闭包函数的作用域链依然在引用着这个活动对象，也就是说，被闭包使用的父级函数，父级函数在使用完之后，也就是从函数环境中被返回的时候，其执行环境的作用域链是会被销毁，而其的活动对象依然是会保留子啊内存中，直至闭包函数的销毁，被回收机制回收，那么，闭包函数的父级函数的活动对象教材会被销毁。
				解除闭包函数的调用：
				闭包函数名 = null;



			<script>
			function f1(){
				var n = 99;
				add=function(){n+=1};
				function f2(){
					console.log(n);
				}
				return f2;
			}
			var result = f1();
			result();
			add();
			result();

			</script>
			结果：
				[Web浏览器] "99"	/js/demo11.html (13)
				[Web浏览器] "100"	/js/demo11.html (13)

			上述代码说明函数f1的变量n是一直保存在内存内存中的，并未在f1调用之后清除。
			解释：
			为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。


		五、使用闭包的注意点

			1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

			2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。